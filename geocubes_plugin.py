# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeocubesPlugin
                                 A QGIS plugin
 Interface to download raster data from GeoCubes Finland
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Paikkatietokeskus FGI
        email                : lassi.lehto@nls.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import (QSettings, QTranslator, qVersion, QCoreApplication, 
                          Qt, QUrl, QEventLoop)
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import (QAction, QTableWidgetItem, QAbstractScrollArea,
                             QSizePolicy, QFileDialog, QTableWidget, QHeaderView,
                             QMessageBox)
from qgis.core import (QgsProject, QgsCoordinateReferenceSystem, QgsRasterLayer,
                       Qgis, QgsVectorLayer, QgsFileDownloader, QgsExpression,
                       QgsFeatureRequest)
from qgis.gui import (QgsBusyIndicatorDialog, QgsMessageBar)

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geocubes_plugin_dialog import GeocubesPluginDialog
import os.path, requests, re
from .MapWindow import MapWindow
from .PolygonMapWindow import PolygonMapWindow


class GeocubesPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeocubesPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeoCubes Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeocubesPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geocubes_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Download harmonised raster data'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GeoCubes Plugin'),
                action)
            self.iface.removeToolBarIcon(action)

    def setResolution(self):
        """Resolution is set to be the one currently in the box"""
        self.resolution = self.resolution_box.currentText()
        
    def setAdminArea(self):
        self.admin_area = self.admin_areas_box.currentText()
        
    def sendWarning(self, title, text, duration, warning=True):
        """Creates an informative warning on the top of the widget"""
        if warning:
            self.msg_bar.pushMessage(title, text, Qgis.Warning,
                                     duration = duration)
        else:
            self.msg_bar.pushMessage(title, text, Qgis.Info,
                                     duration = duration)
    
    def setOptimalResolution(self):
        """
        Automatically suggests a resolution for the current map scale.
        Activated when user moves the canvas and updates the resolution box.
        Suggested resolution is reached via this formula:
        https://www.esri.com/arcgis-blog/products/product/imagery/on-map-scale-and-raster-resolution/?rmedium
        
        Scrap that. It's reached via an ad hoc formula.
        """
        if self.bbox_radio_button.isChecked():
            ext = self.getExtent()
        elif self.admin_radio_button.isChecked():
            ext = self.bboxOfSelectedAreas()
            if not ext:
                self.sendWarning("Resolution can't be calculated", "Please select areas", 5)
                return
        elif self.poly_radio_button.isChecked():
            ext = self.poly_map_canvas.getPolygonBbox()
            if not ext:
                self.sendWarning("Resolution can't be calculated", "Please draw a valid polygon", 5)
                return
        else:
            return

        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        
        x_meter = xmax-xmin
        
        y_meter = ymax-ymin
        
        # this is arbitrary. Increase division values to suggest higher resolution
        # at larger images and vice versa
        divider = 1200
        optimal_resolution = (x_meter/divider) + (y_meter/divider)
        
        """
        # map scale as a double, i.e. 1:563000 -> 563000.000
        map_scale = self.canvas.scale()
        
        detectable_size = map_scale / 1000

        real_resolution = detectable_size / 2
        
        """
        # fetch all resolutions from the box as integers
        all_resolutions = [int(self.resolution_box.itemText(i)) for i in range(self.resolution_box.count())]
        
        # find the resolution closest to the ones available. See:
        # https://stackoverflow.com/questions/12141150/from-list-of-integers-get-number-closest-to-a-given-value
        # in a try clause because it has sometimes errored due to unknown reasons
        try:
            closest_resolution = min(all_resolutions, key=lambda x:abs(x-optimal_resolution))
        except Exception:
            return
        
        resolution_idx = self.resolution_box.findText(str(closest_resolution))
        
        self.resolution_box.setCurrentIndex(resolution_idx)
        
        self.setResolution()
        
        self.updateCountText()
            
    def getDatasets(self):
        """Sends a query to Geocubes and receives text describing the data.
           Returns a list of strings containing the datasets if query succeeds"""
        
        # request info from the server: if no response in 10 seconds, timeout
        response = requests.get(self.url_base + "/info/getDatasets", timeout=6)
        
        # request status code indicates whether succesful: if not, return false
        # and warn user
        status_code = response.status_code
        
        valid_check = self.requestValidity(status_code, "datasets")
        
        if not valid_check:
            return
        else:
            # decode from bytes to string
            dataset_string = response.content.decode("utf-8")
            return dataset_string
    
    def getLabels(self, name):
        """Requests label values for a specific layer and return that csv string"""
        response = requests.get(self.url_base+"/legend/listLabels/"+name,
                                timeout=6)
        status_code = response.status_code
        
        valid_check = self.requestValidity(status_code, "labels")
        
        if not valid_check:
            return
        else:
            # decode from bytes to string
            response_string = response.content.decode("utf-8")
            
            return response_string
        
    def requestValidity(self, s_code, request_type):
        """Checks if the network request errored and shows an informative msg
            to the user."""
        if (s_code == 204):
            self.sendWarning("Empty response", "Failed to fetch " + request_type
                             + ". Error: "+ str(s_code), 8)
            return False
        
        elif (s_code >= 500):
            self.sendWarning("Server error", "Failed to fetch " + request_type +
                             ". Error: "+ str(s_code), 8)
            return False
        
        elif (s_code >= 400):
            self.sendWarning("Client error", "Failed to fetch " + request_type +
                             "Code: "+str(s_code), 8)
            return False
        else:
            return True

    def setToTable(self):
        """
        Activated when user clicks "Fetch datasets" button. This function
        lists available data to the user and creates checkboxes that allow
        the selection of said data. Also creates signals that cannot be
        created on first start, like the signal emitted when clicking 
        on a checkbox.
        """
        # if previous signals exist, i.e. the plugin is started multiple times,
        # remove the connections. If none exist, pass
        try: self.table.itemChanged.disconnect() 
        except Exception: pass

        # get a list of datasets
        dataset_string = self.getDatasets()
        
        # if capabilities query failed, don't run code below
        if not dataset_string:
            return
        
        # datasets are divided by semicolons: split at semicolons
        datasets = dataset_string.split(';')

        self.table.setColumnCount(4)
        # start with only 1 row, add more as needed
        self.table.setRowCount(1)
        # set headers for all 4 columns
        self.table.setHorizontalHeaderLabels(['Label', 'Year', 'Max resolution (m)', 'Select layer'])

        # loop through all the datasets
        for i, dataset in enumerate(datasets):
            # entries in the datasets are separated by commas
            dataset_split = dataset.split(',')

            # each entry has seven pieces of info, but only four are needed

            # label = a plain language name for the dataset: can have spaces etc.
            label = dataset_split[0]

            # name = version of label used in queries etc.
            name = dataset_split[1]
            years = dataset_split[2]
            # maxres = maximum resolution of the dataset in meters
            maxres = dataset_split[5]
            
            bit_depth = dataset_split[6]

            # years are separated by periods
            years_split = years.split('.')
            
            # one dataset may have data from multiple years
            # this is handled by adding each year on its own row
            for year in years_split:
                # the strings must be transformed to Qt Items
                label_entry = QTableWidgetItem(label)
                maxres_entry = QTableWidgetItem(maxres)
                year_entry = QTableWidgetItem(year)
                
                # create a checkbox for each row
                checkbox_entry = QTableWidgetItem()
                checkbox_entry.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                # start with checkbox unchecked
                checkbox_entry.setCheckState(Qt.Unchecked)
                
                # get the current row count from the table
                row_count = self.table.rowCount()
                
                """Next, add info of the dataset to our dictionary. The dict
                will later be accessed via the list of downloadable datasets:
                it will house the keys. This way may seem redundant, but it's done
                since the name variable isn't needed on the table but is later
                necessary for the queries. Key is stored as a string and 
                value as a tuple"""
                key = label + ";" + year
                value = (name, bit_depth, year)
                
                self.datasets_all[key] = value
                
                # add the previously created items on the table
                self.table.setItem(row_count-1, 0, label_entry)
                self.table.setItem(row_count-1, 1, year_entry)
                self.table.setItem(row_count-1, 2, maxres_entry)
                self.table.setItem(row_count-1, 3, checkbox_entry)
                
                # if there're datasets left, add a new row
                if i < len(datasets)-1:
                    self.table.setRowCount(row_count+1)
        
        # fit column sizes to the items
        self.table.resizeColumnsToContents()
        
        # when an item's content are changed, or in this case, when a checkbox
        # is checked or unchecked, run the function
        self.table.itemChanged.connect(self.checkboxState)
        
        # add or subtract from the layer count
        self.table.itemChanged.connect(self.updateCountText)
        
    def deselectDatasets(self):
        """Nullifies selections on the datasets table."""
        for row_id in range(self.table.rowCount()):
            cbox = self.table.item(row_id, 3)
            cbox.setCheckState(0)
            
        self.updateCountText
        
    def updateCountText(self):
        """Activated when checkbox states change. Updates the count accordingly."""
        if not self.resolution:
            res_text = "No resolution selected"
        else:
            res_text = "Resolution set to " + self.resolution + " m"
        if len(self.datasets_to_download) == 1:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layer selected | ' + res_text)
        else:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layers selected | ' + res_text)
        
    def checkboxState(self, cbox):
        """itemChanged signal passes the checkbox (cbox). This function
           checks whether cbox was checked or unchecked and acts accordingly"""
        state = cbox.checkState()
        
        # 0 = unchecked, 2 = checked
        if state == 0:
            self.stateNegative(cbox)
        elif state == 2:
            self.statePositive(cbox)

    def stateNegative(self, cbox):
        """This function is called in case the cbox is unchecked.
           Removes the dataset in question from the list"""
           
        # cbox has a function to access its row number in the table
        # this is used to access label and year items,
        # since they're on the same row and their column number are known
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()
        
        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()
        
        # create key in the same format as before
        dataset_key = label_text + ";" + year_text
        
        # if key already exists, remove it
        if dataset_key in self.datasets_to_download:
            self.datasets_to_download.remove(dataset_key)
    
    def statePositive(self, cbox):
        """This function is called in case the cbox is checked.
           Adds the dataset in question from the list. See above for details"""
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()

        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()

        dataset_key = label_text + ";" + year_text
        self.datasets_to_download.append(dataset_key)

    def deleteDownloads(self):
        """Called when datasets are fetched more than once, which empties the list.
           Also updates layer count text"""
        self.datasets_to_download.clear()
        self.updateCountText()
    
    def estimateFileSize(self):
        """Is activated when user selects a resolution. Estimates the file size
        of a single layer download in MB based on known factors. These are:
        -extent, how many x & y lines there are and therefore, how many pixels
        -radiometric resolution (aka bit depth or data type in QGIS): 8, 16, 32 bits
            As of now, the radiometric resolution is hardcoded to be 16.
        Warns users of too large files (set to 50 MB atm)"""
        if not self.bbox_radio_button.isChecked():
            return
        
        ext = self.getExtent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        
        # (x-axis / resolution) * (y-axis / resolution)
        pixelcount = (xmax-xmin)/int(self.resolution) * ((ymax-ymin)/ int(self.resolution))
        
        data_type = 16
        
        # times radiometric resolution
        size_in_bits = pixelcount * data_type
        
        # size in bits -> to bytes -> to kB -> to MB
        size_in_mb = size_in_bits/8/1024/1024
        
        if size_in_mb > 50:
            self.sendWarning("Layer size warning", "Download is estimated to be: "+
                             str(int(size_in_mb)) + " MB", 6)
        
        
    def getValues(self):
        """Extracts all values (name/year tuples). Returns them as a list"""
        values = []
        
        for dataset_key in self.datasets_to_download:
            # get value by passing the key from the download list
            value = self.datasets_all[dataset_key]
            values.append(value)
            
        return values
            
    def getData(self):
        """
        Downloads raster datasets from Geocubes servers as selected by the user
        This is done by forming an url comprised of layer names, years, extent
        and resolution. Either directly creates a QGis raster layer by 
        passing the url as data source (referred to as temp layer, though strictly
        speaking I don't believe it's saved to some temp folder. Not sure though).
        Another option is to save layers to disk and passing that as the source.
        """
        # nothing will be downloaded if nothing is selected. Notifies user. Else continue
        if(len(self.datasets_to_download) == 0):
            self.sendWarning("Missing data", "Please select one or more data layers!", 8)
        elif not self.resolution:
            self.sendWarning("Missing data", "Please select resolution!", 8)
        elif self.admin_radio_button.isChecked() and len(self.areas_box.checkedItems()) == 0:
            self.sendWarning("Missing selection","Please select admin areas!", 8)
        elif (not self.admin_radio_button.isChecked() and not self.bbox_radio_button.isChecked() 
        and not self.poly_radio_button.isChecked()):
            self.sendWarning("Crop method missing","Please select one of the "+
                                 "three crop methods", 8)
        else:
            # get info that's passed to the Geocubes server
            dataset_parameters = self.getValues()
            
            # while datasets are downloaded, an indicator will be shown
            self.busy_dialog.show()
            
            # a simple count of succesful downloads
            self.successful_layers = 0
        
            self.busy_dialog.show()
            # 1 to n loops to download all selected data
            for parameter in dataset_parameters:
                # accessing values, which are stored as tuples
                name = parameter[0]
                year = parameter[2]
                    
                # forming the url that's passed to server. see:
                # http://86.50.168.160/geocubes/examples/ for examples.
                # Url uses either bbox, polygon or admin areas based on user choice
                if self.bbox_radio_button.isChecked():
                    data_url = self.formBboxUrl(name, year)
                elif self.poly_radio_button.isChecked():
                    data_url = self.formPolygonUrl(name, year)
                else:
                    data_url = self.formAdminUrl(name, year)
                
                if self.save_disk_button.isChecked():
                    if self.gtiff_radio_button.isChecked():
                        file_format = 'tif'
                    else:
                        file_format = 'vrt'
                    self.saveData(data_url, file_format, name)
                    
                else:
                    self.addLayerToQgis(data_url, name=name, year=year)
                    
            # once all layers are downloaded, inform how many were succesful
            data_text = (str(self.successful_layers) + "/" +
                                str(len(dataset_parameters))+ " layer(s)" +
                                " successfully downloaded")
            self.sendWarning("Download complete", data_text, 9, warning=False)


            self.busy_dialog.close()
            self.deselectDatasets()
            self.updateCountText()
            
    def addLayerToQgis(self, url, name="geocubes_raster_layer", year=""):
        """This function receives an url address to access the files at the
            Geocubes servers. It creates a raster layer based on that url, 
            gives it a label and add the layer to QGIS. If the data is
            categorized (say, Corine), then those categories are labeled."""
            
        # creating raster layer by passing the url and giving
        # name and year as layer names
        raster_layer = QgsRasterLayer(url, ''.join([name, '_', year]))
                    
        # if data query fails, inform user. If not, add to Qgis
        if not raster_layer.isValid():
            self.sendWarning("Layer invalid", ''.join([name,'_',year])+
                                     " failed to download", 9)
        else:
            """If raster layer renderer is of type QgsPalettedRasterRenderer,
            it's most likely categorized data that has labels.
            These labels are first queried, then formatted and
            lastly inserted to the layer. Otherwise the step is skipped"""

            if raster_layer.renderer().type() == 'paletted':
                label_string = self.getLabels(name)
                if label_string:
                    label_list = self.formatLabels(label_string)
                    self.insertLabels(label_list, raster_layer.renderer())
                    
            # insert raster layer to main canvas and Qgis legend for use
            QgsProject.instance().addMapLayer(raster_layer)
            self.successful_layers += 1
            
    def bboxOfSelectedAreas(self):
        if self.admin_area == "Blocks":
            column_name = "uleast"
        else:
            column_name = "namefin"
        
        ids = []
        
        items = self.areas_box.checkedItems()
        
        if len(items) == 0:
            return False
        
        for item in items:
            split = item.split('|')
            name = split[0]
            
            expression = QgsExpression("\"{}\"='{}'".format(column_name, name))
            
            iterator = self.vlayer.getFeatures(QgsFeatureRequest(expression))
            
            index = [i.id() for i in iterator]
            
            ids.append(index[0])
        
        self.vlayer.selectByIds(ids)
        
        bbox = self.vlayer.boundingBoxOfSelected()
        
        self.vlayer.removeSelection()
        
        return bbox

    def downloadFailed(self, error):
        """Run in case the file downloader errors"""
        self.loop.exit()
        self.sendWarning("Download failed", "Error: " + str(error), 10)
        
    def downloadSucceeded(self, file_name, name):
        """If the downloader succeeds, the file has now been downloaded on disk
            It will be added to QGIS as a layer via the file path given by user"""
        self.loop.exit()
        self.addLayerToQgis(file_name, name=name)
            
    def saveData(self, url, file_format, name):
        """This function first asks the user for a file name, then downloads
            the raster file from the server using the url from getData and
            saves it as the defined file name."""
        self.loop = QEventLoop()
        file_name, file_filter = QFileDialog.getSaveFileName(self.dlg,
                                "Save " + name, filter='Selected format: (*'+file_format+')')
        if not file_name:
            self.sendWarning("Filename required", "Please write filenames", 10)
            return
        
        split = file_name.split('.')
        if len(split) == 1:
            file_name = file_name + '.' + file_format
        
        # downloader requires url as QUrl
        qt_url = QUrl(url)
        
        # this handles the download and then destructs
        downloader = QgsFileDownloader(qt_url, file_name)
        
        # signals for both fail and success
        downloader.downloadError.connect(self.downloadFailed)
        downloader.downloadCompleted.connect(lambda: self.downloadSucceeded(file_name, name))
        
        downloader.startDownload()
        
        self.loop.exec_()
    
    def formatLabels(self, label_string):
        """Server returns a string with items separated by commas. This function
            formats that data so that the output is a list of tuples. The tuples
            consist of an index number (which value the label refers to) and
            the label itself.
            """
        label_list = label_string.split(';')
        formatted_labels = []
        
        for label in label_list:
            # example label looks like this: Uusimaa(1)
            # splitting at bracket allows us to handle both name and idx
            split_label = label.split("(")
            name = split_label[0]
            number_string = split_label[len(split_label)-1]
            
            # a regex query is made to catch 1 to n numbers
            regex_nmr = re.search("[0-9]+", number_string)
            
            # if the query fails, do nothing. Else, add to list
            if regex_nmr is None:
                pass
            else:
                nmr = regex_nmr.group()
                formatted_label = (nmr, name)
                formatted_labels.append(formatted_label)
                
        return formatted_labels
    
    def insertLabels(self, labels, renderer):
        """Renderer houses classification of the data. Method combines the labels
            with the correct raster values (index values)"""
        for label in labels:
            index = int(label[0])
            name = label[1]

            renderer.setLabel(index, name)
                            
    def formBboxUrl(self, name, year):
        """Forms the url for a bbox clip"""
        extent = self.getExtent()
        bbox_url = (self.url_base + "/clip/" + self.resolution +
                        "/"+ name +"/bbox:" + self.formatExtent(extent)
                        + "/" + year)
        
        if self.vrt_radio_button.isChecked():
            bbox_url = bbox_url+"/vrt/mr"
        return bbox_url
    
    def formAdminUrl(self, name, year):
        """Forms the url for an admin area clip"""
        areas = self.areas_box.checkedItems()
        admin_url = (self.url_base + "/clip/" + self.resolution +"/"+ name +
                     "/"+self.admin_area.lower()+":" + self.formatAreas(areas)
                        + "/" + year)
        if self.vrt_radio_button.isChecked():
            admin_url = admin_url+"/vrt/mr"
        return admin_url
    
    def formPolygonUrl(self, name, year):
        """Forms the url for an user drawn polygon clip"""
        poly_url = (self.url_base + "/clip/" + self.resolution +
                    "/"+ name +"/polygon:" + self.formatPolygon()
                    + "/" + year)
        return poly_url
            
    def getAreas(self):
        """Fetches a vector data of administrative divisions from Geocubes WFS 
           server. Passes this on to another function."""

        # don't do anything if the box is empty
        if not self.admin_area:
            return
        
        # create a string to fetch the correct data
        area_name = "ogiir:" + self.admin_area.lower()
        if self.admin_area != "Blocks":
            area_name = area_name + "_2018_4500k"
        
        self.busy_dialog.show()
        url = ("http://86.50.168.160/geoserver/ows?service=wfs&version=2.0.0"+ 
        "&request=GetFeature&typename="+area_name+"&pagingEnabled=true")
        
        # pass url, label and data provider
        vector_layer = QgsVectorLayer(url, "WFS-layer-REMOVE", "WFS")
        
        if not vector_layer.isValid():
            self.sendWarning("Query error", "WFS query failed", 8)
            self.busy_dialog.close()
        else:
            # if everything went well, run another function on the layer
            if self.admin_area == "Blocks":
                self.updateAreaBox(vector_layer, block_flag = True)
            else:
                self.updateAreaBox(vector_layer)
            self.vlayer = vector_layer

    def openMapWindow(self):
        """Check if user has selected an admin layer. If yes, pass a copy of 
            that layer to the window and open it"""
        if (not self.vlayer or not self.admin_areas_box.currentText()):
            self.sendWarning("Layer missing", "Select admin division first", 6)
        else:
            # vector layer itself can't be passed to the mapwindow, since
            # it's removed from project after use â€“ removal deletes the layer.
            # Therefore, an exact copy is created
            scrap_vlayer = self.vlayer.clone()
            if self.admin_area == "Blocks":
                self.map_canvas.addBlocksLayer(scrap_vlayer)
            else:
                self.map_canvas.addLayer(scrap_vlayer)

    def openPolyMapWindow(self):
        self.poly_map_canvas.showCanvas()
        
    def getMapPolygon(self):
        """Activated when signal indicating polygon drawing is finished is emitted.
            Gets the list of point values and does a simple but hopefully exhaustive
            check of the polygon validity. Warn the user if the polygon is faulty.
            If valid, indicate by checking the appropriate box."""
        
        self.polygon_list = self.poly_map_canvas.getPolygon()
        
        # assumes that the polygon must have at least 3 points. First and last
        # points must also be the same (this error shoudln't happen but who knows)
        if (len(self.polygon_list)<3 or not self.polygon_list[0] ==
        self.polygon_list[len(self.polygon_list)-1]):
            self.sendWarning("Invalid polygon", "Please redraw polygon", 8)
            self.polygon_list.clear()
            self.poly_checkbox.setChecked(False)
        else:
            self.poly_checkbox.setChecked(True)
            
    def mapSelectionToBox(self):
        """Activated when map canvas emits 'finished' signal. Gets a list of
            items selected by the user and checks these on the areas box"""
        self.areas_box.deselectAllOptions()
        map_selection = self.map_canvas.getSelection()
        self.areas_box.setCheckedItems(map_selection)
            
    def updateAreaBox(self, vlayer, block_flag = False):
        """Populates the selectable box with whatever administrative areas
            the user has picked."""
        self.areas_box.clear()
        name_list = []
        block_minus = 0
        
        # blocks' attribute tables are different than the rest
        # the features wanted are on a different column, hence the need to
        # subtract from the column count
        if block_flag:
            block_minus = 1
        
        # loop through features or rows in the layer
        for feature in vlayer.getFeatures():
            name_fi = feature[2-block_minus]
            id_code = feature[1-block_minus]
            # create a string from Finnish name and id code
            if block_flag:
                key = str(id_code) + "|" + str(name_fi)
            else:
                key = name_fi + "|" + str(id_code)
            
            name_list.append(key)
                
        name_list.sort()
        # add all area strings to the box
        self.areas_box.addItems(name for name in name_list)
        self.busy_dialog.close()
    
    def updateExtent(self):
        """Updates extent boxes when the canvas extent changes"""
        self.extent_box.setCurrentExtent(self.canvas.extent(), self.proj_crs)
        self.extent_box.setOutputExtentFromCurrent()
            
    def getExtent(self):
        """Current extent shown in the extent groupbox
        Returns a rectangle object"""
        output_extent = self.extent_box.outputExtent()
        return output_extent
    
        """
        QgsMessageLog.logMessage(output_extent,
                                 'geocubes_plugin',
                                 Qgis.Info)
        """
        
    def questionCrs(self):
        """Called if QGIS' CRS isn't EPSG:3067. Asks the user to change destination
            CRS and changes if allowed. If refused, warns the user."""
            
        buttonReply = QMessageBox.question(self.dlg, 'Incorrect CRS set', 
                        "Plugin requires CRS to be EPSG:3067 to function correctly. "+
                        "Do you want to change the current destination CRS to EPSG:3067?"
                        "\nNOTE: Project CRS on the lower right corner will not change.",
                        QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if buttonReply == QMessageBox.Yes:
            self.canvas.setDestinationCrs(self.proj_crs)
        else:
            self.sendWarning("Incorrect CRS set", "Some features may not work"+
                             " or they function incorrectly", 7)
    
    def formatPolygon(self):
        """Returns polygons in a url form suitable for the Geocubes API.
        Takes a list of PointXY's (tuples consisting of coordinate doubles) and
        trims the at the decimal point. Returns as a string with each value
        separated by comma."""
        polygon_str = ""
        for point in self.polygon_list:
            if not polygon_str:
                point_str = str(int(point.x()))+","+str(int(point.y()))
                polygon_str = point_str
            else:
                point_str =","+str(int(point.x()))+","+str(int(point.y()))
                polygon_str = polygon_str + point_str
        
        return polygon_str
        
    def formatExtent(self,rectangle):
        """The extent coordinates need to be in certain format for the url
            This function's input is a Qgis rectangle and output a bbox string"""
        formatted_extent = (str(rectangle.xMinimum())+','+str(rectangle.yMinimum())
                            +','+str(rectangle.xMaximum())+','+str(rectangle.yMaximum()))
        return formatted_extent
    
    def formatAreas(self, areas):
        """Return areas selected by user in a format suitable for the url. Id codes
            are used to identify features. Nationwide (valtakunta) is a special case, since
            it's handled differently to the other datasets serverside. Blocks
            are also handled in a slightly different manner"""
            
        if self.admin_area == 'Valtakunta':
            return str(1)
        if self.admin_area == "Blocks":
            codes = ""
            for area in areas:
                area_split = area.split("|")
                code = area_split[0] + "," + area_split[1]
                if not codes:
                    codes = code
                else:
                    codes = codes + "," + code
            return codes
        else:
            # empty string forms a basis for the formatting
            codes = ""
            # loop through 1 to n areas. For each, add id code to string
            for area in areas:
                area_split = area.split("|")
                code = area_split[len(area_split)-1]
                if not codes:
                    codes = code
                else:
                    codes = codes + "," + code
            return codes
        
    def run(self):
        """Run method that initializes the plugin and its variables"""

        # if the plugin is started for the first time,
        # create necessary variables and connect signals to slots
        # signal/slot connection must only be made once;
        # unless disconnected elsewhere
        if self.first_start is True:
            self.first_start = False
            # the ui
            self.dlg = GeocubesPluginDialog()
            
            # table to house the datasets: also add policies to fit the data
            # better on the table
            self.table = self.dlg.tableWidget
            """
            self.table.setSizeAdjustPolicy(
                    QAbstractScrollArea.AdjustToContents)
            """
            self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.table.horizontalHeader().setStretchLastSection(True) 
            
            #ensures entries in the table cannot be edited
            self.table.setEditTriggers(QTableWidget.NoEditTriggers)
            
            # connect click of the fetch data layers button to functions
            self.dlg.getContents.clicked.connect(self.setToTable)
            self.dlg.getContents.clicked.connect(self.deleteDownloads)
            
            # QGIS canvas
            self.canvas = self.iface.mapCanvas()
            self.canvas.extentsChanged.connect(self.updateExtent)

            # initialising the extent box
            # all the data is in ETRS89 / TM35FIN (EPSG:3067), 
            # therefore that's the default crs
            self.extent_box = self.dlg.mExtentGroupBox
            self.proj_crs = QgsCoordinateReferenceSystem('EPSG:3067')
            #self.extent_box.extentChanged.connect(self.extentResolution)

            
            # box housing a drop-down list of possible raster resolutions
            self.resolution_box = self.dlg.resolutionBox
            self.resolution_box.activated.connect(self.setResolution)
            
            # estimate download file size when resolution changes
            self.resolution_box.activated.connect(self.estimateFileSize)
            
            self.resolution_box.activated.connect(self.updateCountText)
            
            self.data_button = self.dlg.getDataButton
            self.data_button.clicked.connect(self.getData)
            
            self.map_select_button = self.dlg.mapSelectButton
            self.map_select_button.clicked.connect(self.openMapWindow)
            
            self.poly_draw_button = self.dlg.polyDrawButton
            self.poly_draw_button.clicked.connect(self.openPolyMapWindow)
            
            self.optimal_res_button = self.dlg.optimalResolutionButton
            self.optimal_res_button.clicked.connect(self.setOptimalResolution)
            
            # text that tells the user the current count of selected layers
            self.layer_count_text = self.dlg.layerCountText
            
            # radio buttons for user to decide whether to get the data as
            # temporary layers or save the rasters to disc
            self.save_temp_button = self.dlg.saveToTempButton
            self.save_disk_button = self.dlg.saveToDiskButton
            
            # radio buttons to decide what to use when cropping the data
            self.bbox_radio_button = self.dlg.bboxRadioButton
            self.admin_radio_button = self.dlg.adminRadioButton
            self.poly_radio_button = self.dlg.polyRadioButton
            
            self.gtiff_radio_button = self.dlg.gtiffRadioButton
            self.vrt_radio_button = self.dlg.vrtRadioButton
            
            
            self.admin_areas_box = self.dlg.adminAreasBox
            self.areas_box = self.dlg.areasBox
            # below are the possible admin area divisions. Adjust if these
            # change. Use the same names as the WFS server
            admin_area_labels = ['Valtakunta', 'Aluehallintovirastojako', 
                                 'Maakuntajako', 'Kuntajako', 'Blocks']
            self.admin_areas_box.addItems(label for label in admin_area_labels)
            self.admin_areas_box.currentTextChanged.connect(self.setAdminArea)
            self.admin_areas_box.currentTextChanged.connect(self.getAreas)
            
            self.checkedAreas = []
            
            self.busy_dialog = QgsBusyIndicatorDialog("Processing... Please wait", self.dlg)
            
            # initiate message bar that warns user when something goes wrong
            self.msg_bar = QgsMessageBar(self.dlg.tabWidget)
            self.msg_bar.setMinimumSize(575, 80)
            self.msg_bar.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
            
            # false to indicate no vector layer is selected: will change, if
            # user selects an admin area
            self.vlayer = False
            
            self.map_canvas = MapWindow()
            self.map_canvas.finished.connect(self.mapSelectionToBox)
            
            self.poly_map_canvas = PolygonMapWindow()
            self.poly_map_canvas.finished.connect(self.getMapPolygon)
            
            # an empty dictionary to house all the fetched datasets
            self.datasets_all = {}
        
            # an empty list for only the datasets the user has selected
            self.datasets_to_download = []
            
            self.poly_checkbox = self.dlg.polyCheckbox
            
            # list of possible resolutions. Update if this changes
            resolutions = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000]
            self.resolution_box.addItems(str(resolution) for resolution in resolutions)
            
        """Code below is ran every time the plugin is restarted but Qgis isn't"""
        
        # current base url (shared by all queries) of the Geocubes project. Modify if url changes
        self.url_base = "http://86.50.168.160/geocubes"
        
        # set the box empty by default
        self.resolution_box.setCurrentIndex(-1)
        
        # this variable houses the currently selected resolution
        self.resolution = self.resolution_box.currentText()
        
        self.admin_areas_box.setCurrentIndex(-1)
        self.admin_area = self.admin_areas_box.currentText()
        
        
        #self.extentResolution()
        
        # set default text
        self.updateCountText()
        
        #self.bbox_radio_button.setChecked(True)
        
        self.save_temp_button.setChecked(True)
        
        self.gtiff_radio_button.setChecked(True)
        
        self.areas_box.clear()
        
        self.deselectDatasets()
        
        # show the dialog
        self.dlg.show()
        
        # if QGIS' CRS is not EPSG:3067, ask user if they want to change it
        if self.canvas.mapSettings().destinationCrs() != self.proj_crs:
            self.questionCrs()

        # canvas extent at the start
        og_extent = self.canvas.extent()
        
        # these three things must be set when initialising the extent box
        self.extent_box.setOriginalExtent(og_extent, self.canvas.mapSettings().destinationCrs())
        self.extent_box.setCurrentExtent(og_extent, self.proj_crs)
        self.extent_box.setOutputCrs(self.proj_crs)
        
        # push current extent to the box
        self.updateExtent()